---
title: "Distribución Normal"
lang: es
---

```{=html}
<style>
main.content {
text-align: justify}
</style>
```

```{r setup, include=FALSE}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(knitr)
library(kableExtra)
library(moments)
```

La distribución normal, también conocida como distribución gaussiana en honor al matemático alemán Carl Friedrich Gauss, es sin duda la más importante y ampliamente utilizada de todas las distribuciones de probabilidad continuas. Su relevancia en la estadística y en diversas áreas del conocimiento es fundamental por varias razones:

**Importancia teórica:** La distribución normal aparece de manera natural en muchos fenómenos debido al Teorema del Límite Central, que establece que la suma de un gran número de variables aleatorias independientes tiende a seguir una distribución normal, independientemente de las distribuciones individuales de dichas variables.

**Aplicaciones prácticas:** Numerosos fenómenos en la naturaleza, ciencias sociales, ingeniería y otras disciplinas pueden ser modelados adecuadamente mediante la distribución normal: alturas y pesos de poblaciones, errores de medición, puntajes en pruebas estandarizadas, variaciones en procesos industriales, entre muchos otros.

**Propiedades matemáticas:** Posee propiedades analíticas muy convenientes que facilitan los cálculos estadísticos y el desarrollo de métodos inferenciales, convirtiéndola en la base de gran parte de la teoría estadística clásica.

::: {#def-dist_normal}
Una **variable aleatoria continua** $X$ sigue una **distribución normal** con parámetros $\mu$ (media) y $\sigma^2$ (varianza), denotada como $X \sim N(\mu, \sigma^2)$, si su función de densidad de probabilidad está dada por:

$$f(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^2}$$

donde:

-   $x \in \mathbb{R}$ (la variable puede tomar cualquier valor real)
-   $\mu \in \mathbb{R}$ es el parámetro de localización (media de la distribución)
-   $\sigma > 0$ es el parámetro de escala (desviación estándar)
-   $\sigma^2$ es la varianza de la distribución
:::

------------------------------------------------------------------------

La distribución normal es simétrica alrededor de su media $\mu$ y es completamente caracterizada por sus dos parámetros $\mu$ y $\sigma^2$.

**Caso especial:** Cuando $\mu = 0$ y $\sigma^2 = 1$, se denomina **distribución normal estándar** y se denota como $Z \sim N(0,1)$.

## Propiedades de la Función de Densidad de Probabilidad

**Componentes de la PDF**

La función puede descomponerse en tres elementos fundamentales:

1.  **Factor de normalización**: $\frac{1}{\sigma\sqrt{2\pi}}$
2.  **Componente de localización**: $(x - \mu)$ en el exponente
3.  **Componente exponencial**: $e^{-\frac{1}{2}z^2}$ donde $z = \frac{x-\mu}{\sigma}$

**Verificación de Propiedades de Densidad**

**1. No Negatividad**

$$f(x; \mu, \sigma) > 0 \text{ para todo } x \in \mathbb{R}$$

Esto se cumple porque:

-   $\frac{1}{\sigma\sqrt{2\pi}} > 0$ (ya que $\sigma > 0$)
-   $e^{-\frac{1}{2}z^2} > 0$ (la función exponencial es siempre positiva)

**2. Integración Unitaria** $$\int_{-\infty}^{\infty} f(x; \mu, \sigma) dx = 1$$

**Verificación Numérica**

```{r verificacion-propiedades}
# Verificación numérica de propiedades
mu_ver <- 2
sigma_ver <- 1.5

# Verificar integración unitaria mediante integración numérica
integrando <- function(x) dnorm(x, mean = mu_ver, sd = sigma_ver)
integral_resultado <- integrate(integrando, lower = -Inf, upper = Inf)


cat("Distribución: N(μ =", mu_ver, ", σ =", sigma_ver, ")\n")
cat("Integral de la PDF:", round(integral_resultado$value, 8), "\n")
cat("Error de integración:", integral_resultado$abs.error, "\n")
cat("No negatividad: f(x) > 0 para todo x ∈ ℝ ✓\n")
```

### Comportamiento de la PDF al variar los Parámetros

**Efecto del Parámetro de Localización (**$\mu$)

El parámetro $\mu$ controla la **posición** de la distribución en el eje x:

```{r efecto-mu}
# Visualizar efecto de μ (σ fijo)
x_vals <- seq(-6, 10, length.out = 1000)
sigma_fijo <- 1.5
mus <- c(-1, 1, 3, 5)

df_mu <- data.frame()
for (mu in mus) {
  temp <- data.frame(
    x = x_vals,
    y = dnorm(x_vals, mean = mu, sd = sigma_fijo),
    parametro = paste("μ =", mu),
    tipo = "Efecto de μ (σ = 1.5)"
  )
  df_mu <- rbind(df_mu, temp)
}

ggplot(df_mu, aes(x = x, y = y, color = parametro)) +
  geom_line(linewidth = 1.2) +
  geom_vline(xintercept = mus, linetype = "dashed", alpha = 0.7, 
             color = c("red", "green", "blue", "purple")) +
  labs(title = "Efecto del Parámetro de Localización μ",
       subtitle = "Desplazamiento horizontal de la distribución",
       x = "x", y = "f(x)",
       color = "Parámetro μ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

**Efecto del Parámetro de Escala (**$\sigma$)

El parámetro $\sigma$ controla la **dispersión** de la distribución:

```{r efecto-sigma}
# Visualizar efecto de σ (μ fijo)
mu_fijo <- 2
sigmas <- c(0.5, 1, 1.5, 2.5)

df_sigma <- data.frame()
for (sigma in sigmas) {
  temp <- data.frame(
    x = x_vals,
    y = dnorm(x_vals, mean = mu_fijo, sd = sigma),
    parametro = paste("σ =", sigma),
    tipo = "Efecto de σ (μ = 2)"
  )
  df_sigma <- rbind(df_sigma, temp)
}

ggplot(df_sigma, aes(x = x, y = y, color = parametro)) +
  geom_line(linewidth = 1.2) +
  geom_vline(xintercept = mu_fijo, linetype = "dashed", color = "black", alpha = 0.7) +
  labs(title = "Efecto del Parámetro de Escala σ",
       subtitle = "Cambio en la dispersión de la distribución",
       x = "x", y = "f(x)",
       color = "Parámetro σ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

### Propiedades Geométricas de la PDF

**1. Simetría**

La distribución normal es **perfectamente simétrica** respecto a la media:

$$f(\mu + x) = f(\mu - x) \text{ para todo } x \in \mathbb{R}$$

**2. Forma de Campana**

La función tiene la característica forma de **campana de Gauss**:

-   **Máximo único** en $x = \mu$ con valor $f(\mu) = \frac{1}{\sigma\sqrt{2\pi}}$
-   **Decrecimiento** simétrico hacia ambos lados
-   **Colas** que se extienden hacia $\pm\infty$ pero nunca tocan el eje x

**3. Puntos de Inflexión**

Los puntos de inflexión ocurren en $x = \mu \pm \sigma$:

$$f''(\mu \pm \sigma) = 0$$

```{r}
#| label: puntos-inflexion

# Visualizar puntos de inflexión
mu_inf <- 3
sigma_inf <- 1.2

x_inf <- seq(mu_inf - 4*sigma_inf, mu_inf + 4*sigma_inf, length.out = 1000)
y_inf <- dnorm(x_inf, mean = mu_inf, sd = sigma_inf)

# Puntos de inflexión
inflexion_x <- c(mu_inf - sigma_inf, mu_inf + sigma_inf)
inflexion_y <- dnorm(inflexion_x, mean = mu_inf, sd = sigma_inf)

ggplot(data.frame(x = x_inf, y = y_inf), aes(x = x, y = y)) +
  geom_line(linewidth = 1.5, color = "blue") +
  geom_vline(xintercept = mu_inf, color = "red", linetype = "dashed", linewidth = 1) +
  geom_vline(xintercept = inflexion_x, color = "green", linetype = "dotted", linewidth = 1) +
  annotate("point", x = inflexion_x, y = inflexion_y, color = "olivedrab", size = 4) +
  annotate("label", x = mu_inf, y = max(y_inf) * 1.1, 
           label = paste("μ =", mu_inf), color = "red", size = 4) +
  annotate("label", x = inflexion_x[1], y = inflexion_y[1] + 0.02,
           label = "μ - σ", color = "olivedrab", size = 3.5) +
  annotate("label", x = inflexion_x[2], y = inflexion_y[2] + 0.02,
           label = "μ + σ", color = "olivedrab", size = 3.5) +
  labs(title = "Propiedades Geométricas de la PDF Normal",
       subtitle = paste("N(", mu_inf, ",", sigma_inf, ") - Puntos de inflexión en μ ± σ"),
       x = "x", y = "f(x)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

**4. Comportamiento Asintótico**

Cuando $x \to \pm\infty$: $$\lim_{x \to \pm\infty} f(x) = 0$$

El decaimiento es **exponencial cuadrático**, más rápido que cualquier función polinomial.

## Estandarización y Distribución Normal Estándar

**Transformación** $Z$

Cualquier variable con distribución normal puede estandarizarse mediante: $$Z = \frac{X - \mu}{\sigma} \sim N(0, 1)$$

La **distribución normal estándar** tiene PDF: $$\phi(z) = \frac{1}{\sqrt{2\pi}} e^{-\frac{z^2}{2}}$$

```{r estandarizacion}
# Comparar distribución original vs estandarizada
mu_est <- 5
sigma_est <- 2

# Generar datos
x_orig <- seq(mu_est - 4*sigma_est, mu_est + 4*sigma_est, length.out = 1000)
z_vals <- (x_orig - mu_est) / sigma_est

# PDFs
pdf_orig <- dnorm(x_orig, mean = mu_est, sd = sigma_est)
pdf_std <- dnorm(z_vals, mean = 0, sd = 1)

# Crear dataframe para gráfico
df_comparacion <- data.frame(
  x = c(x_orig, z_vals),
  y = c(pdf_orig, pdf_std),
  tipo = rep(c("Original N(5,2)", "Estandarizada N(0,1)"), each = length(x_orig)),
  eje_x = rep(c("Escala original", "Escala estandarizada"), each = length(x_orig))
)

ggplot(df_comparacion, aes(x = x, y = y, color = tipo)) +
  geom_line(linewidth = 1.2) +
  facet_wrap(~eje_x, scales = "free_x") +
  labs(title = "Estandarización de la Distribución Normal",
       subtitle = "Transformación Z = (X - μ)/σ",
       x = "Valor", y = "f(x) o φ(z)",
       color = "Distribución") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

## Regla Empírica (68-95-99.7)

Una propiedad fundamental de la distribución normal es la **regla empírica**:

```{r regla-empirica}
# Calcular probabilidades de la regla empírica
prob_1sigma <- pnorm(1) - pnorm(-1)  # P(-1 < Z < 1)
prob_2sigma <- pnorm(2) - pnorm(-2)  # P(-2 < Z < 2)
prob_3sigma <- pnorm(3) - pnorm(-3)  # P(-3 < Z < 3)

regla_empirica <- data.frame(
  Intervalo = c("μ ± 1σ", "μ ± 2σ", "μ ± 3σ"),
  `Notación Z` = c("[-1, 1]", "[-2, 2]", "[-3, 3]"),
  `Probabilidad Exacta` = c(prob_1sigma, prob_2sigma, prob_3sigma),
  `Aproximación Empírica` = c(0.68, 0.95, 0.997),
  `Porcentaje` = c("68%", "95%", "99.7%"),
  check.names = FALSE
)

kable(regla_empirica,
      caption = "Regla empírica de la distribución normal",
      digits = 4) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

# Visualizar la regla empírica
z_seq <- seq(-4, 4, length.out = 1000)
phi_vals <- dnorm(z_seq)

# Areas para cada sigma
z_1sigma <- z_seq[abs(z_seq) <= 1]
z_2sigma <- z_seq[abs(z_seq) <= 2 & abs(z_seq) > 1]
z_3sigma <- z_seq[abs(z_seq) <= 3 & abs(z_seq) > 2]

phi_1sigma <- dnorm(z_1sigma)
phi_2sigma <- dnorm(z_2sigma)
phi_3sigma <- dnorm(z_3sigma)

ggplot(data.frame(z = z_seq, phi = phi_vals), aes(x = z, y = phi)) +
  geom_line(linewidth = 1.5, color = "black") +
  geom_area(data = data.frame(z = z_1sigma, phi = phi_1sigma),
            aes(x = z, y = phi), fill = "red", alpha = 0.3) +
  geom_area(data = data.frame(z = z_2sigma, phi = phi_2sigma),
            aes(x = z, y = phi), fill = "orange", alpha = 0.3) +
  geom_area(data = data.frame(z = z_3sigma, phi = phi_3sigma),
            aes(x = z, y = phi), fill = "yellow", alpha = 0.3) +
  geom_vline(xintercept = c(-3, -2, -1, 0, 1, 2, 3), 
             linetype = "dashed", alpha = 0.6) +
  annotate("text", x = 0, y = 0.2, label = "68%", size = 4, fontface = "bold") +
  annotate("text", x = 1.5, y = 0.1, label = "13.5%", size = 3.5) +
  annotate("text", x = -1.5, y = 0.1, label = "13.5%", size = 3.5) +
  annotate("text", x = 2.5, y = 0.05, label = "2.35%", size = 3) +
  annotate("text", x = -2.5, y = 0.05, label = "2.35%", size = 3) +
  labs(title = "Regla Empírica 68-95-99.7",
       subtitle = "Distribución de probabilidades en intervalos estándar",
       x = "Z (desviaciones estándar desde la media)",
       y = "φ(z)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

## Propiedades de la Función de Distribución Acumulativa

::: {#def-cdf_normal}
La función de distribución acumulativa (CDF) de la distribución normal se define como:

$$F(x) = P(X \leq x) = \int_{-\infty}^{x} \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{1}{2}\left(\frac{t-\mu}{\sigma}\right)^2} dt$$
:::

------------------------------------------------------------------------

**Relación con la CDF Estándar**

La CDF normal se expresa en términos de la **función de distribución normal estándar** $\Phi(z)$:

$$F(x) = \Phi\left(\frac{x-\mu}{\sigma}\right)$$

donde: $$\Phi(z) = \frac{1}{\sqrt{2\pi}} \int_{-\infty}^{z} e^{-\frac{t^2}{2}} dt$$

**Observación**: La CDF normal **no tiene forma cerrada** en términos de funciones elementales. Su cálculo requiere:

-   **Integración numérica**
-   **Series de Taylor**
-   **Aproximaciones asintóticas**
-   **Tablas precalculadas**

### Propiedades Fundamentales de la CDF

**Simetría de la CDF**

Una propiedad crucial es la **simetría** respecto a la media:

$$F(\mu + x) + F(\mu - x) = 1$$

Verificación numérica:

```{r simetria-cdf}
# Demostrar simetría de la CDF
mu_sim <- 2
sigma_sim <- 1
x_test <- 1.5

# Puntos simétricos
punto_der <- mu_sim + x_test
punto_izq <- mu_sim - x_test

# CDFs
cdf_der <- pnorm(punto_der, mu_sim, sigma_sim)
cdf_izq <- pnorm(punto_izq, mu_sim, sigma_sim)
suma_simetria <- cdf_der + cdf_izq

cat("Distribución: N(", mu_sim, ",", sigma_sim, ")\n")
cat("Puntos: μ - x =", punto_izq, ", μ + x =", punto_der, "\n")
cat("F(μ - x) =", round(cdf_izq, 4), "\n")
cat("F(μ + x) =", round(cdf_der, 4), "\n")
cat("Suma =", round(suma_simetria, 4), "\n")
cat("¿F(μ + x) + F(μ - x) = 1?", abs(suma_simetria - 1) < 1e-10, "\n")
```

### Efecto de los Parámetros en la CDF

```{r visualizacion-cdf}
# Visualizar CDFs con diferentes parámetros
x_range_cdf <- seq(-6, 10, length.out = 1000)

# Efecto de μ
mus_cdf <- c(-1, 1, 3, 5)
sigma_fijo_cdf <- 1.5

df_mu_cdf <- data.frame()
for (mu in mus_cdf) {
  temp <- data.frame(
    x = x_range_cdf,
    y = pnorm(x_range_cdf, mean = mu, sd = sigma_fijo_cdf),
    parametro = paste("μ =", mu),
    tipo = "Efecto de μ (σ = 1.5)"
  )
  df_mu_cdf <- rbind(df_mu_cdf, temp)
}

# Efecto de σ
mu_fijo_cdf <- 2
sigmas_cdf <- c(0.5, 1, 1.5, 2.5)

df_sigma_cdf <- data.frame()
for (sigma in sigmas_cdf) {
  temp <- data.frame(
    x = x_range_cdf,
    y = pnorm(x_range_cdf, mean = mu_fijo_cdf, sd = sigma),
    parametro = paste("σ =", sigma),
    tipo = "Efecto de σ (μ = 2)"
  )
  df_sigma_cdf <- rbind(df_sigma_cdf, temp)
}

# Combinar datos
df_cdf_efectos <- rbind(df_mu_cdf, df_sigma_cdf)

# Crear gráfico
ggplot(df_cdf_efectos, aes(x = x, y = y, color = parametro)) +
  geom_line(linewidth = 1.2) +
  geom_hline(yintercept = c(0, 0.5, 1), linetype = "dashed", alpha = 0.5) +
  facet_wrap(~tipo, scales = "free_x", ncol = 2) +
  labs(title = "Función de Distribución Acumulativa - Distribución Normal",
       subtitle = "Efecto de los parámetros μ y σ",
       x = "x", y = "F(x) = P(X ≤ x)",
       color = "Parámetro") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  ylim(0, 1)
```

**Comparación: PDF vs CDF**

```{r pdf-vs-cdf-normal}
# Comparar PDF y CDF lado a lado
mu_comp <- 3
sigma_comp <- 1.2

x_comp <- seq(mu_comp - 4*sigma_comp, mu_comp + 4*sigma_comp, length.out = 1000)
pdf_comp <- dnorm(x_comp, mean = mu_comp, sd = sigma_comp)
cdf_comp <- pnorm(x_comp, mean = mu_comp, sd = sigma_comp)

# Crear dataframe
df_comparacion_normal <- data.frame(
  x = rep(x_comp, 2),
  y = c(pdf_comp, cdf_comp),
  tipo = rep(c("PDF: f(x)", "CDF: F(x)"), each = length(x_comp))
)

ggplot(df_comparacion_normal, aes(x = x, y = y)) +
  geom_line(linewidth = 1.2, color = "blue") +
  geom_vline(xintercept = mu_comp, linetype = "dashed", color = "red", alpha = 0.7) +
  facet_wrap(~tipo, scales = "free_y", ncol = 2) +
  labs(title = paste("Comparación PDF vs CDF: N(", mu_comp, ",", sigma_comp, ")"),
       x = "x", y = "Valor de la función") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```

## Cálculo de Probabilidades

Para calcular $P(a < X \leq b)$ en una distribución normal:

$$P(a < X \leq b) = F(b) - F(a) = \Phi\left(\frac{b-\mu}{\sigma}\right) - \Phi\left(\frac{a-\mu}{\sigma}\right)$$

```{r calculo-probabilidades}
# Ejemplo de cálculo de probabilidades
mu_prob <- 50
sigma_prob <- 12
a_val <- 45
b_val <- 60

# Calcular diferentes tipos de probabilidades
prob_menor_igual_b <- pnorm(b_val, mu_prob, sigma_prob)
prob_mayor_a <- 1 - pnorm(a_val, mu_prob, sigma_prob)
prob_intervalo <- pnorm(b_val, mu_prob, sigma_prob) - pnorm(a_val, mu_prob, sigma_prob)

# Calcular usando estandarización
z_a <- (a_val - mu_prob) / sigma_prob
z_b <- (b_val - mu_prob) / sigma_prob
prob_intervalo_std <- pnorm(z_b) - pnorm(z_a)

# Tabla de probabilidades
tabla_prob <- data.frame(
  `Tipo de Probabilidad` = c(
    paste("P(X ≤", b_val, ")"),
    paste("P(X >", a_val, ")"),
    paste("P(", a_val, "< X ≤", b_val, ")"),
    "P(a < X ≤ b) vía Z"
  ),
  `Fórmula` = c(
    paste("F(", b_val, ")"),
    paste("1 - F(", a_val, ")"),
    paste("F(", b_val, ") - F(", a_val, ")"),
    paste("Φ(", round(z_b, 2), ") - Φ(", round(z_a, 2), ")")
  ),
  `Valor` = round(c(prob_menor_igual_b, prob_mayor_a, prob_intervalo, prob_intervalo_std), 4),
  `Interpretación` = c(
    "Probabilidad acumulada hasta b",
    "Probabilidad de cola superior",
    "Probabilidad en intervalo",
    "Mismo resultado vía estandarización"
  ),
  check.names = FALSE
)

kable(tabla_prob,
      caption = paste("Cálculo de probabilidades para N(", mu_prob, ",", sigma_prob, ")")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

**Visualización del Área Bajo la Curva**

```{r area-bajo-curva}
# Crear visualización del área bajo la curva
x_area <- seq(mu_prob - 4*sigma_prob, mu_prob + 4*sigma_prob, length.out = 1000)
pdf_area <- dnorm(x_area, mean = mu_prob, sd = sigma_prob)

# Identificar el área de interés
x_intervalo <- x_area[x_area > a_val & x_area <= b_val]
pdf_intervalo <- pdf_area[x_area > a_val & x_area <= b_val]

# Crear el gráfico
ggplot(data.frame(x = x_area, y = pdf_area), aes(x = x, y = y)) +
  geom_line(linewidth = 1.5, color = "blue") +
  geom_area(data = data.frame(x = x_intervalo, y = pdf_intervalo),
            aes(x = x, y = y), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = c(a_val, b_val), linetype = "dashed", color = "red", linewidth = 1) +
  geom_vline(xintercept = mu_prob, linetype = "dotted", color = "black", linewidth = 1) +
  annotate("label", x = mean(c(a_val, b_val)), y = max(pdf_area) * 0.3,
           label = paste("P(", a_val, "< X ≤", b_val, ") =", round(prob_intervalo, 3)),
           size = 4, color = "red", fontface = "bold") +
  annotate("label", x = mu_prob, y = max(pdf_area) * 1.1,
           label = paste("μ =", mu_prob), size = 3.5) +
  labs(title = "Cálculo de Probabilidades usando Área Bajo la Curva",
       subtitle = paste("Distribución N(", mu_prob, ",", sigma_prob, ")"),
       x = "x", y = "f(x)",
       caption = "El área sombreada representa la probabilidad del intervalo") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

## Cuantiles de la Distribución Normal

### Función Cuantil

El cuantil $x_p$ se define como el valor que satisface: $F(x_p; \mu, \sigma) = p$

Para la distribución normal: $x_p = \mu + \sigma \cdot \Phi^{-1}(p)$

donde $\Phi^{-1}(p)$ es la función cuantil de la normal estándar.

```{r cuantiles-normal}
# Calcular cuantiles importantes
percentiles <- c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99)

# Para diferentes distribuciones normales
configuraciones_cuant <- list(
  "N(0, 1)" = list(mu = 0, sigma = 1),
  "N(100, 15)" = list(mu = 100, sigma = 15),
  "N(-5, 2)" = list(mu = -5, sigma = 2)
)

# Crear tabla de cuantiles
tabla_cuantiles <- data.frame(
  Percentil = paste0(percentiles * 100, "%"),
  `Z crítico` = round(qnorm(percentiles), 3)
)

for (nombre in names(configuraciones_cuant)) {
  config <- configuraciones_cuant[[nombre]]
  cuantiles <- qnorm(percentiles, mean = config$mu, sd = config$sigma)
  tabla_cuantiles[[nombre]] <- round(cuantiles, 2)
}

kable(tabla_cuantiles,
      caption = "Cuantiles para diferentes distribuciones normales") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%")
```

### Valores Críticos Importantes

```{r valores-criticos}
# Valores críticos comunes
valores_criticos <- data.frame(
  `Nombre` = c("1.96", "2.58", "1.64", "1.28", "2.33"),
  `Valor Z` = c(1.96, 2.58, 1.645, 1.282, 2.326),
  `Probabilidad` = c(0.975, 0.995, 0.95, 0.90, 0.99),
  `Intervalo Central` = c("95%", "99%", "90%", "80%", "98%"),
  `Uso Común` = c(
    "IC 95%, pruebas bilaterales",
    "IC 99%, pruebas bilaterales", 
    "Pruebas unilaterales α = 0.05",
    "Pruebas unilaterales α = 0.10",
    "Pruebas unilaterales α = 0.01"
  ),
  check.names = FALSE
)

kable(valores_criticos,
      caption = "Valores críticos importantes de la distribución normal estándar") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

### Visualización de Cuantiles en la CDF

```{r visualizacion-cuantiles}
# Mostrar cuantiles en el gráfico de CDF
mu_q <- 10
sigma_q <- 3
x_q <- seq(mu_q - 4*sigma_q, mu_q + 4*sigma_q, length.out = 1000)
cdf_q <- pnorm(x_q, mean = mu_q, sd = sigma_q)

# Cuantiles específicos
p_vals <- c(0.25, 0.5, 0.75)
q_vals <- qnorm(p_vals, mean = mu_q, sd = sigma_q)

# Crear puntos para los cuantiles
df_cuantiles <- data.frame(
  x = q_vals,
  y = p_vals,
  etiqueta = paste0("Q", p_vals*100, " = ", round(q_vals, 1))
)

ggplot(data.frame(x = x_q, y = cdf_q), aes(x = x, y = y)) +
  geom_line(linewidth = 1.5, color = "blue") +
  geom_hline(yintercept = p_vals, linetype = "dashed", color = "red", alpha = 0.7) +
  geom_vline(xintercept = q_vals, linetype = "dashed", color = "red", alpha = 0.7) +
  geom_point(data = df_cuantiles, aes(x = x, y = y), 
             color = "red", size = 3) +
  geom_label(data = df_cuantiles, aes(x = x, y = y, label = etiqueta),
            vjust = -0.5, hjust = 0.5, size = 3.5) +
  labs(title = paste("Cuantiles en la CDF: N(", mu_q, ",", sigma_q, ")"),
       x = "x", y = "F(x)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  ylim(0, 1)
```

## Propiedades de Simetría y Complementariedad

### Relaciones de Simetría

Para la distribución normal estándar:

1.  **Simetría**: $\Phi(-z) = 1 - \Phi(z)$
2.  **Complemento**: $P(Z > z) = 1 - \Phi(z) = \Phi(-z)$
3.  **Intervalo simétrico**: $P(-z < Z < z) = 2\Phi(z) - 1$

```{r propiedades-simetria}
# Verificar propiedades de simetría
z_simetria <- c(0.5, 1, 1.5, 2, 2.5, 3)

verificacion_simetria <- data.frame(
  z = z_simetria,
  `Φ(z)` = round(pnorm(z_simetria), 4),
  `Φ(-z)` = round(pnorm(-z_simetria), 4),
  `1 - Φ(z)` = round(1 - pnorm(z_simetria), 4),
  `P(-z < Z < z)` = round(2*pnorm(z_simetria) - 1, 4),
  `Verificación` = round(pnorm(-z_simetria), 4) == round(1 - pnorm(z_simetria), 4),
  check.names = FALSE
)

kable(verificacion_simetria,
      caption = "Verificación de propiedades de simetría") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

# Visualizar la simetría
z_sym <- seq(-3, 3, length.out = 1000)
phi_sym <- dnorm(z_sym)
cdf_sym <- pnorm(z_sym)

# Punto específico para mostrar simetría
z_punto <- 1.5
punto_neg <- -z_punto
cdf_pos <- pnorm(z_punto)
cdf_neg <- pnorm(punto_neg)

ggplot(data.frame(z = z_sym, phi = phi_sym, cdf = cdf_sym)) +
  geom_line(aes(x = z, y = phi), linewidth = 1.2, color = "blue") +
  geom_area(data = data.frame(z = z_sym[z_sym <= punto_neg], 
                             phi = phi_sym[z_sym <= punto_neg]),
            aes(x = z, y = phi), fill = "red", alpha = 0.3) +
  geom_area(data = data.frame(z = z_sym[z_sym >= z_punto], 
                             phi = phi_sym[z_sym >= z_punto]),
            aes(x = z, y = phi), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = c(punto_neg, z_punto), linetype = "dashed", color = "red") +
  annotate("text", x = punto_neg, y = 0.3, 
           label = paste("Φ(", punto_neg, ") =", round(cdf_neg, 3)), 
           angle = 90, vjust = -0.5, size = 3.5) +
  annotate("text", x = z_punto, y = 0.3, 
           label = paste("1 - Φ(", z_punto, ") =", round(1 - cdf_pos, 3)), 
           angle = 90, vjust = 1.5, size = 3.5) +
  labs(title = "Propiedad de Simetría: Φ(-z) = 1 - Φ(z)",
       subtitle = "Las áreas sombreadas son iguales",
       x = "z", y = "φ(z)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

## Simulación y Comparación con Parámetros Teóricos

Consideremos una distribución $N(\mu = 75, \sigma^2 = 144)$, es decir $N(75, 12^2)$:

```{r parametros-simulacion}
# Parámetros de la distribución normal
mu_sim <- 75
sigma_sim <- 12

# Parámetros teóricos
media_teorica <- mu_sim
varianza_teorica <- sigma_sim^2
desv_std_teorica <- sigma_sim
mediana_teorica <- mu_sim  # Por simetría
moda_teorica <- mu_sim     # Unimodal en μ

cat("Distribución: N(μ =", mu_sim, ", σ² =", varianza_teorica, ")\n")
cat("Media teórica:", media_teorica, "\n")
cat("Mediana teórica:", mediana_teorica, "\n")
cat("Moda teórica:", moda_teorica, "\n")
cat("Varianza teórica:", varianza_teorica, "\n")
cat("Desviación estándar teórica:", desv_std_teorica, "\n")
cat("Coeficiente de variación teórico:", round(desv_std_teorica/media_teorica, 4), "\n")
```

**Simulación con Diferentes Tamaños de Muestra**

```{r simulacion-convergencia}
# Diferentes tamaños de muestra
tamaños_muestra <- c(30, 100, 500, 1000, 5000, 10000)

# Función para calcular estadísticos muestrales
calcular_estadisticos_normal <- function(n, mu, sigma) {
  muestra <- rnorm(n, mean = mu, sd = sigma)
  
  return(data.frame(
    n = n,
    media_muestral = mean(muestra),
    varianza_muestral = var(muestra),
    desv_std_muestral = sd(muestra),
    mediana_muestral = median(muestra),
    min_muestral = min(muestra),
    max_muestral = max(muestra),
    q1_muestral = quantile(muestra, 0.25),
    q3_muestral = quantile(muestra, 0.75)
  ))
}

# Realizar simulaciones
resultados_simulacion <- do.call(rbind, lapply(tamaños_muestra, calcular_estadisticos_normal, 
                                              mu = mu_sim, sigma = sigma_sim))

# Agregar valores teóricos y errores
resultados_simulacion$media_teorica <- media_teorica
resultados_simulacion$varianza_teorica <- varianza_teorica
resultados_simulacion$desv_std_teorica <- desv_std_teorica
resultados_simulacion$mediana_teorica <- mediana_teorica
resultados_simulacion$asimetria_teorica <- 0
resultados_simulacion$curtosis_teorica <- 3

# Calcular errores relativos
resultados_simulacion$error_media <- abs(resultados_simulacion$media_muestral - media_teorica) / media_teorica * 100
resultados_simulacion$error_varianza <- abs(resultados_simulacion$varianza_muestral - varianza_teorica) / varianza_teorica * 100
resultados_simulacion$error_desv_std <- abs(resultados_simulacion$desv_std_muestral - desv_std_teorica) / desv_std_teorica * 100

# Mostrar tabla de resultados principales
tabla_principales <- resultados_simulacion[, c("n", "media_muestral", "media_teorica", "error_media",
                                               "varianza_muestral", "varianza_teorica", "error_varianza",
                                               "desv_std_muestral", "desv_std_teorica", "error_desv_std")]

kable(tabla_principales,
      caption = "Convergencia de estadísticos muestrales hacia valores teóricos",
      digits = 3,
      col.names = c("n", "Media Obs.", "Media Teór.", "Error %",
                    "Var. Obs.", "Var. Teór.", "Error %",
                    "DE Obs.", "DE Teór.", "Error %")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) 
```

<br>

**Visualización de la Convergencia (Ley de Grandes Números)**

```{r ley-grandes-numeros}
#| warning: false

# Generar una secuencia larga para observar convergencia
n_total <- 15000
muestra_larga <- rnorm(n_total, mean = mu_sim, sd = sigma_sim)

# Calcular estadísticos acumulados
indices <- 1:n_total
medias_acumuladas <- cumsum(muestra_larga) / indices
varianzas_acumuladas <- sapply(indices, function(i) var(muestra_larga[1:i]))
desv_std_acumuladas <- sqrt(varianzas_acumuladas)

# Crear dataframe para gráficos
df_convergencia <- data.frame(
  n = indices,
  media_acumulada = medias_acumuladas,
  varianza_acumulada = varianzas_acumuladas,
  desv_std_acumulada = desv_std_acumuladas
)

# Gráfico de convergencia de la media
p1 <- ggplot(df_convergencia, aes(x = n)) +
  geom_line(aes(y = media_acumulada), color = "blue", alpha = 0.8) +
  geom_hline(yintercept = media_teorica, color = "red", linetype = "dashed", linewidth = 1) +
  labs(title = "Convergencia de la Media Muestral",
       x = "Tamaño de muestra (n)",
       y = "Media acumulada",
       caption = paste("Línea roja: Media teórica =", media_teorica)) +
  theme_minimal() +
  ylim(media_teorica - 2, media_teorica + 2)

# Gráfico de convergencia de la desviación estándar
p2 <- ggplot(df_convergencia, aes(x = n)) +
  geom_line(aes(y = desv_std_acumulada), color = "green", alpha = 0.8) +
  geom_hline(yintercept = desv_std_teorica, color = "red", linetype = "dashed", linewidth = 1) +
  labs(title = "Convergencia de la Desviación Estándar",
       x = "Tamaño de muestra (n)",
       y = "Desviación estándar acumulada",
       caption = paste("Línea roja: DE teórica =", desv_std_teorica)) +
  theme_minimal() +
  ylim(desv_std_teorica - 2, desv_std_teorica + 2)

# Mostrar ambos gráficos
grid.arrange(p1, p2, ncol = 2,
             top = "Ley de Grandes Números - Distribución Normal")
```

**Comparación Histograma vs Densidad Teórica**

```{r histograma-densidad}
# Generar muestra grande para comparación visual
muestra_grande <- rnorm(10000, mean = mu_sim, sd = sigma_sim)

# Crear histograma con densidad teórica superpuesta
ggplot(data.frame(x = muestra_grande), aes(x = x)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50, 
                 fill = "lightblue", color = "black", alpha = 0.7) +
  stat_function(fun = dnorm, args = list(mean = mu_sim, sd = sigma_sim),
                color = "red", linewidth = 2) +
  geom_vline(xintercept = media_teorica, color = "red", linetype = "dashed", linewidth = 1) +
  geom_vline(xintercept = c(mu_sim - sigma_sim, mu_sim + sigma_sim), 
             color = "orange", linetype = "dotted", linewidth = 1) +
  labs(title = "Histograma de Muestra vs Densidad Teórica",
       subtitle = paste("10,000 observaciones de N(", mu_sim, ",", sigma_sim, "²)"),
       x = "Valores",
       y = "Densidad",
       caption = "Curva roja: Densidad teórica | Línea roja: μ | Líneas naranjas: μ ± σ") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

**Verificación de la Regla Empírica**

```{r verificacion-regla-empirica}
# Verificar la regla 68-95-99.7 con la muestra simulada
n_muestra_regla <- 10000
muestra_regla <- rnorm(n_muestra_regla, mean = mu_sim, sd = sigma_sim)

# Intervalos teóricos
intervalo_1sigma <- c(mu_sim - sigma_sim, mu_sim + sigma_sim)
intervalo_2sigma <- c(mu_sim - 2*sigma_sim, mu_sim + 2*sigma_sim)
intervalo_3sigma <- c(mu_sim - 3*sigma_sim, mu_sim + 3*sigma_sim)

# Proporciones observadas
prop_1sigma_obs <- mean(muestra_regla >= intervalo_1sigma[1] & muestra_regla <= intervalo_1sigma[2])
prop_2sigma_obs <- mean(muestra_regla >= intervalo_2sigma[1] & muestra_regla <= intervalo_2sigma[2])
prop_3sigma_obs <- mean(muestra_regla >= intervalo_3sigma[1] & muestra_regla <= intervalo_3sigma[2])

# Proporciones teóricas
prop_1sigma_teo <- pnorm(1) - pnorm(-1)
prop_2sigma_teo <- pnorm(2) - pnorm(-2)
prop_3sigma_teo <- pnorm(3) - pnorm(-3)

# Crear tabla de verificación
verificacion_regla <- data.frame(
  Intervalo = c("μ ± 1σ", "μ ± 2σ", "μ ± 3σ"),
  `Rango Numérico` = c(
    paste("[", round(intervalo_1sigma[1], 1), ",", round(intervalo_1sigma[2], 1), "]"),
    paste("[", round(intervalo_2sigma[1], 1), ",", round(intervalo_2sigma[2], 1), "]"),
    paste("[", round(intervalo_3sigma[1], 1), ",", round(intervalo_3sigma[2], 1), "]")
  ),
  `Proporción Teórica` = c(prop_1sigma_teo, prop_2sigma_teo, prop_3sigma_teo),
  `Porcentaje Teórico` = c("68.27%", "95.45%", "99.73%"),
  `Proporción Observada` = c(prop_1sigma_obs, prop_2sigma_obs, prop_3sigma_obs),
  `Porcentaje Observado` = paste0(round(c(prop_1sigma_obs, prop_2sigma_obs, prop_3sigma_obs) * 100, 2), "%"),
  `Error Absoluto` = abs(c(prop_1sigma_obs, prop_2sigma_obs, prop_3sigma_obs) - 
                        c(prop_1sigma_teo, prop_2sigma_teo, prop_3sigma_teo)),
  check.names = FALSE
)

kable(verificacion_regla,
      caption = paste("Verificación de la regla empírica con", n_muestra_regla, "observaciones"),
      digits = 4) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Ejemplos Prácticos

::: {#exm-control_calidad}
### Control de Calidad en Manufactura

Una fábrica produce tornillos cuyo diámetro sigue una distribución normal con media $\mu = 8.00 mm$ y desviación estándar $\sigma = 0.15 mm$. Los tornillos se consideran defectuosos si su diámetro está fuera del rango \[7.70, 8.30\] mm.

```{r ejemplo-manufactura}
# Parámetros del proceso
mu_tornillos <- 8.00  # mm
sigma_tornillos <- 0.15  # mm
limite_inferior <- 7.70
limite_superior <- 8.30

# Simulación de un lote de producción
n_lote <- 5000
set.seed(456)
diametros <- rnorm(n_lote, mean = mu_tornillos, sd = sigma_tornillos)

# Análisis de calidad
dentro_especificacion <- sum(diametros >= limite_inferior & diametros <= limite_superior)
defectos_pequeños <- sum(diametros < limite_inferior)
defectos_grandes <- sum(diametros > limite_superior)

porcentaje_calidad <- (dentro_especificacion / n_lote) * 100
porcentaje_def_pequeños <- (defectos_pequeños / n_lote) * 100
porcentaje_def_grandes <- (defectos_grandes / n_lote) * 100

# Cálculos teóricos
prob_calidad_teorica <- pnorm(limite_superior, mu_tornillos, sigma_tornillos) - 
                       pnorm(limite_inferior, mu_tornillos, sigma_tornillos)
prob_def_pequeños_teorica <- pnorm(limite_inferior, mu_tornillos, sigma_tornillos)
prob_def_grandes_teorica <- 1 - pnorm(limite_superior, mu_tornillos, sigma_tornillos)

cat("=== ANÁLISIS DE CONTROL DE CALIDAD ===\n")
cat("Proceso: Diámetro ~ N(8.00, 0.15²) mm\n")
cat("Especificación: [7.70, 8.30] mm\n")
cat("Lote simulado:", n_lote, "tornillos\n\n")

cat("RESULTADOS DE CALIDAD:\n")
cat("• Tornillos dentro de especificación:", dentro_especificacion, "(", round(porcentaje_calidad, 2), "%)\n")
cat("• Defectos por tamaño pequeño:", defectos_pequeños, "(", round(porcentaje_def_pequeños, 2), "%)\n")
cat("• Defectos por tamaño grande:", defectos_grandes, "(", round(porcentaje_def_grandes, 2), "%)\n\n")

cat("COMPARACIÓN CON VALORES TEÓRICOS:\n")
cat("• Calidad teórica:", round(prob_calidad_teorica * 100, 2), "%\n")
cat("• Defectos pequeños teórico:", round(prob_def_pequeños_teorica * 100, 2), "%\n")
cat("• Defectos grandes teórico:", round(prob_def_grandes_teorica * 100, 2), "%\n")


# Visualización
ggplot(data.frame(diametro = diametros), aes(x = diametro)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50, 
                 fill = "lightblue", color = "black", alpha = 0.7) +
  stat_function(fun = dnorm, args = list(mean = mu_tornillos, sd = sigma_tornillos),
                color = "red", linewidth = 2) +
  geom_vline(xintercept = c(limite_inferior, limite_superior), 
             color = "darkgreen", linewidth = 2, linetype = "dashed") +
  geom_vline(xintercept = mu_tornillos, color = "red", linewidth = 1, linetype = "dotted") +
  annotate("rect", xmin = limite_inferior, xmax = limite_superior,
           ymin = 0, ymax = Inf, alpha = 0.1, fill = "green") +
  labs(title = "Control de Calidad: Diámetro de Tornillos",
       subtitle = "Zona verde: Especificación aceptable",
       x = "Diámetro (mm)",
       y = "Densidad") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```
:::

::::::::: {#exm-sistema_respuesta}
### Análisis de Tiempos de Respuesta de un Sistema

Los tiempos de respuesta de un sistema informático siguen una distribución normal con media $\mu = 2.5$ segundos y desviación estándar $\sigma = 0.8$ segundos. Se requiere evaluar el rendimiento del sistema bajo diferentes cargas de trabajo.

```{r ejemplo-sistema}
#| warning: false

# Parámetros del sistema
mu_sistema <- 2.5  # segundos
sigma_sistema <- 0.8  # segundos

# Simular tiempos de respuesta durante diferentes períodos
n_solicitudes <- 3000
set.seed(101112)
tiempos_respuesta <- rnorm(n_solicitudes, mean = mu_sistema, sd = sigma_sistema)

# Filtrar tiempos negativos (no físicamente posibles)
tiempos_respuesta <- tiempos_respuesta[tiempos_respuesta > 0]
n_validos <- length(tiempos_respuesta)

# Análisis de SLA (Service Level Agreement)
sla_excelente <- 1.5  # < 1.5 seg
sla_bueno <- 3.0      # < 3.0 seg  
sla_aceptable <- 4.5  # < 4.5 seg
sla_inaceptable <- 6.0 # ≥ 6.0 seg

# Calcular cumplimiento de SLA
cumple_excelente <- mean(tiempos_respuesta < sla_excelente) * 100
cumple_bueno <- mean(tiempos_respuesta < sla_bueno) * 100
cumple_aceptable <- mean(tiempos_respuesta < sla_aceptable) * 100
sobre_inaceptable <- mean(tiempos_respuesta >= sla_inaceptable) * 100

# Cálculos teóricos
cum_excelente_teo <- pnorm(sla_excelente, mu_sistema, sigma_sistema) * 100
cum_bueno_teo <- pnorm(sla_bueno, mu_sistema, sigma_sistema) * 100
cum_aceptable_teo <- pnorm(sla_aceptable, mu_sistema, sigma_sistema) * 100
sobre_inaceptable_teo <- (1 - pnorm(sla_inaceptable, mu_sistema, sigma_sistema)) * 100


cat("Distribución: Tiempo ~ N(2.5, 0.8²) segundos\n")
cat("Solicitudes analizadas:", n_validos, "\n\n")

cat("CUMPLIMIENTO DE SLA:\n")
cat("• Excelente (< 1.5s): ", round(cumple_excelente, 1), "% (Teórico: ", round(cum_excelente_teo, 1), "%)\n")
cat("• Bueno (< 3.0s): ", round(cumple_bueno, 1), "% (Teórico: ", round(cum_bueno_teo, 1), "%)\n")
cat("• Aceptable (< 4.5s): ", round(cumple_aceptable, 1), "% (Teórico: ", round(cum_aceptable_teo, 1), "%)\n")
cat("• Inaceptable (≥ 6.0s): ", round(sobre_inaceptable, 1), "% (Teórico: ", round(sobre_inaceptable_teo, 1), "%)\n\n")

# Estadísticos del sistema
media_observada <- mean(tiempos_respuesta)
mediana_observada <- median(tiempos_respuesta)
p95_observado <- quantile(tiempos_respuesta, 0.95)
p99_observado <- quantile(tiempos_respuesta, 0.99)

# Teóricos
p95_teorico <- qnorm(0.95, mu_sistema, sigma_sistema)
p99_teorico <- qnorm(0.99, mu_sistema, sigma_sistema)

cat("MÉTRICAS DE RENDIMIENTO:\n")
cat("• Tiempo promedio: ", round(media_observada, 3), "s (Teórico: ", mu_sistema, "s)\n")
cat("• Tiempo mediano: ", round(mediana_observada, 3), "s (Teórico: ", mu_sistema, "s)\n")
cat("• Percentil 95: ", round(p95_observado, 3), "s (Teórico: ", round(p95_teorico, 3), "s)\n")
cat("• Percentil 99: ", round(p99_observado, 3), "s (Teórico: ", round(p99_teorico, 3), "s)\n")

# Análisis de capacidad del sistema
# ¿Qué porcentaje del tiempo el sistema responde en menos de 2 segundos?
objetivo_2s <- pnorm(2, mu_sistema, sigma_sistema) * 100
objetivo_2s_obs <- mean(tiempos_respuesta < 2) * 100

cat("\nANÁLISIS DE CAPACIDAD:\n")
cat("• Respuestas < 2s: ", round(objetivo_2s_obs, 1), "% (Teórico: ", round(objetivo_2s, 1), "%)\n")

# Mejora del sistema: ¿Qué pasa si reducimos σ a 0.6?
sigma_mejorado <- 0.6
mejora_bueno <- pnorm(sla_bueno, mu_sistema, sigma_mejorado) * 100
mejora_excelente <- pnorm(sla_excelente, mu_sistema, sigma_mejorado) * 100

cat("• Con mejora (σ = 0.6): Bueno ", round(mejora_bueno, 1), "%, Excelente ", round(mejora_excelente, 1), "%\n")

# Visualización
ggplot(data.frame(tiempo = tiempos_respuesta), aes(x = tiempo)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50, 
                 fill = "lightgreen", color = "black", alpha = 0.7) +
  stat_function(fun = dnorm, args = list(mean = mu_sistema, sd = sigma_sistema),
                color = "darkgreen", linewidth = 2) +
  geom_vline(xintercept = c(sla_excelente, sla_bueno, sla_aceptable, sla_inaceptable), 
             color = c("green", "orange", "red", "darkred"), 
             linewidth = c(2, 2, 2, 2), linetype = "dashed") +
  geom_vline(xintercept = mu_sistema, color = "blue", linewidth = 2) +
  annotate("text", x = sla_excelente, y = 0.4, label = "Excelente\n< 1.5s", 
           color = "green", size = 3, angle = 90, vjust = -0.5) +
  annotate("text", x = sla_bueno, y = 0.35, label = "Bueno\n< 3.0s", 
           color = "orange", size = 3, angle = 90, vjust = -0.5) +
  annotate("text", x = sla_aceptable, y = 0.3, label = "Aceptable\n< 4.5s", 
           color = "red", size = 3, angle = 90, vjust = -0.5) +
  labs(title = "Análisis de Tiempos de Respuesta del Sistema",
       subtitle = "Líneas verticales indican niveles de SLA",
       x = "Tiempo de respuesta (segundos)",
       y = "Densidad") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  xlim(0, 7)
```

## Ejercicios Propuestos

::: {#exr-altura}
### Análisis de Altura de Estudiantes

Las alturas de estudiantes universitarios siguen una distribución normal con media $\mu = 170 cm$ y desviación estándar $\sigma = 8 cm$.

1.  Simula una muestra de 500 estudiantes

2.  Calcula la media, mediana y desviación estándar muestral
3.  ¿Qué porcentaje de estudiantes mide más de 180 cm?
4.  ¿Cuál es la altura del estudiante en el percentil 25?
5.  Crea un histograma de la muestra con la densidad teórica superpuesta


```{r}
# Generamos la muestra
mu_altura <- 170
sigma_altura <- 8

muestra_altura <- rnorm(500, mean = mu_altura, sd = sigma_altura )
media_altura <- mean(muestra_altura)
mediana_altura <- median(muestra_altura)
sd_altura <- sd(muestra_altura)

cat("La media de la altura es:", media_altura, "\n")
cat("La mediana de la altura es:", mediana_altura, "\n")
cat("La sd de la altura es:", sd_altura, "\n")

```


```{r}
dist_altura <- tibble(
  estaturas = seq(mu_altura - 4* sigma_altura, mu_altura + 4* sigma_altura,length=1000),
  pdf_altura = dnorm(estaturas, mean = mu_altura, sd= sigma_altura),
  cdf_altrua = pnorm(estaturas, mean = mu_altura, sd= sigma_altura)
)

ggplot(dist_altura)+
  geom_line(aes(estaturas, pdf_altura), color = "#333AAA", linewidth=1.3)+
  geom_area(data = dist_altura |> filter(estaturas >=180), aes(estaturas, pdf_altura), fill= "firebrick", alpha=0.5)+
  geom_vline(xintercept = 180, linetype ="dashed")+
  annotate("label", x=190, y=0.01, 
           label = paste("1-F(180)= ", round(pnorm(180, mu_altura, sigma_altura, lower.tail = FALSE), 4) ), color = "black", size=3, fill = "yellow")+
  theme_bw()                                           
                                                                 

```


```{r}
ggplot()+
  geom_histogram(aes(muestra_altura, y=after_stat(density)), fill = "#277653", color= "#111888", center = 170)+ 
  geom_line(data = dist_altura, aes(estaturas, pdf_altura), color = "pink", linewidth = 1.3)+
  theme_bw()
```

:::





------------------------------------------------------------------------

::: {#exr-temperatura}
### Control de Temperatura Industrial

Un proceso industrial debe mantener la temperatura a 350°C ± 10°C. Las temperaturas siguen $N(350, 5^2)$.

1.  Simular un día de producción (1000 mediciones)
2.  ¿Qué porcentaje del tiempo la temperatura está fuera de especificación?
3.  Si el proceso se descentra a $\mu = 355°C$, ¿cómo cambia la calidad?
4.  ¿Qué $\sigma$ se necesita para tener 99.9% de productos dentro de especificación?


```{r}
# Especificaciones del proceso
mu <- 350
sigma <- 5
lim_inf <- 340
lim_sup <- 360
n_mediciones <- 1000
set.seed(2025)
# Simulación de temperaturas
temperaturas <- rnorm(n_mediciones, mean = mu, sd = sigma)

# Filtrar valores fuera de rango físico si aplica (no necesario aquí)
n_validas <- length(temperaturas)

# Límites de especificación
lim_inf <- 340
lim_sup <- 360

# Empírico
fuera_especificacion <- mean(temperaturas < lim_inf | temperaturas > lim_sup) * 100

# Teórico
fuera_especificacion_teo <- (pnorm(lim_inf, mu, sigma) + (1 - pnorm(lim_sup, mu, sigma))) * 100

# Nuevo centro del proceso
mu_descentrado <- 355

# Simulación
temperaturas_descentradas <- rnorm(n_mediciones, mean = mu_descentrado, sd = sigma)

# Empírico
fuera_descentrado <- mean(temperaturas_descentradas < lim_inf | temperaturas_descentradas > lim_sup) * 100

# Teórico
fuera_descentrado_teo <- (pnorm(lim_inf, mu_descentrado, sigma) + (1 - pnorm(lim_sup, mu_descentrado, sigma))) * 100
# Cálculo de sigma requerido
z_9995 <- qnorm(0.9995)
sigma_requerido <- 10 / z_9995

cat("Distribución: Tiempo ~ N(2.5, 0.8²) segundos\n\n")

cat("Cumplimiento SLA (empírico):\n")
cat(sprintf("Excelente (< %.1f seg): %.2f%%\n", sla_excelente, cumple_excelente))
cat(sprintf("Bueno     (< %.1f seg): %.2f%%\n", sla_bueno, cumple_bueno))
cat(sprintf("Aceptable (< %.1f seg): %.2f%%\n", sla_aceptable, cumple_aceptable))
cat(sprintf("Inaceptable (≥ %.1f seg): %.2f%%\n\n", sla_inaceptable, sobre_inaceptable))

cat("Cumplimiento SLA (teórico):\n")
cat(sprintf("Excelente (< %.1f seg): %.2f%%\n", sla_excelente, cum_excelente_teo))
cat(sprintf("Bueno     (< %.1f seg): %.2f%%\n", sla_bueno, cum_bueno_teo))
cat(sprintf("Aceptable (< %.1f seg): %.2f%%\n", sla_aceptable, cum_aceptable_teo))
cat(sprintf("Inaceptable (≥ %.1f seg): %.2f%%\n", sla_inaceptable, sobre_inaceptable_teo))


```


```{r}
# Estadísticos observados del sistema térmico
media <- mean(temperaturas)
mediana_temp <- median(temperaturas)
p95_temp_obs <- quantile(temperaturas, 0.95)
p99_temp_obs <- quantile(temperaturas, 0.99)

# Estadísticos teóricos
p95_temp_teo <- qnorm(0.95, mean = mu, sd = sigma)
p99_temp_teo <- qnorm(0.99, mean = mu, sd = sigma)


cat("Distribución: Temperatura ~ N(350, 5²) °C\n")
cat("Mediciones analizadas:", n_validas, "\n\n")

cat("MÉTRICAS DE RENDIMIENTO:\n")
cat(sprintf("Media observada:     %.2f °C\n", media))
cat(sprintf("Mediana observada:   %.2f °C\n", mediana_temp))
cat(sprintf("Percentil 95 (obs):  %.2f °C\n", p95_temp_obs))
cat(sprintf("Percentil 99 (obs):  %.2f °C\n\n", p99_temp_obs))

cat("VALORES TEÓRICOS:\n")
cat(sprintf("Percentil 95 (teo):  %.2f °C\n", p95_temp_teo))
cat(sprintf("Percentil 99 (teo):  %.2f °C\n", p99_temp_teo))


```

```{r}
# Desviación del proceso: μ = 355 °C
mu_descentrado <- 355
sigma_actual <- 5

# Límites de especificación
lim_inf <- 340
lim_sup <- 360

# Cumplimiento teórico con proceso descentrado
cumplimiento_bajo <- pnorm(lim_sup, mu_descentrado, sigma_actual) * 100 - pnorm(lim_inf, mu_descentrado, sigma_actual) * 100

cat("• Con desviación (μ = 355°C): Dentro de especificación ", round(cumplimiento_bajo, 1), "%\n")



```

```{r}
ggplot(data.frame(temp = temperaturas), aes(x = temp)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50, 
                 fill = "lightblue", color = "black", alpha = 0.7) +
  stat_function(fun = dnorm, args = list(mean = mu, sd = sigma),
                color = "pink", linewidth = 2) +
  geom_vline(xintercept = c(lim_inf, lim_sup), 
             color = c("red", "red"), 
             linewidth = 2, linetype = "dashed") +
  geom_vline(xintercept = mu, color = "darkgreen", linewidth = 2) +
  annotate("text", x = lim_inf, y = 0.04, label = "Límite Inferior\n340°C", 
           color = "black", size = 3, angle = 90, vjust = -0.5) +
  annotate("text", x = lim_sup, y = 0.04, label = "Límite Superior\n360°C", 
           color = "black", size = 3, angle = 90, vjust = -0.5) +
  labs(title = "Distribución de Temperatura del Proceso Industrial",
       subtitle = "Líneas verticales indican límites de especificación",
       x = "Temperatura (°C)",
       y = "Densidad") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  xlim(330, 370)

```



```{r}
# Cálculo de sigma requerido para 99.9% dentro de especificación
z_9995 <- qnorm(0.9995)
sigma_requerido <- (lim_sup - mu) / z_9995

```


```{r}
cat("\nMEJORA DEL SISTEMA:\n")
cat(sprintf("• Para lograr 99.9%% dentro de especificación (340°C–360°C), se requiere σ ≈ %.2f°C\n", sigma_requerido))

```
## Comparativa

```{r}
# Densidades comparativas
x_vals <- seq(330, 370, length.out = 500)
dens_actual <- dnorm(x_vals, mean = mu, sd = 5)
dens_mejorado <- dnorm(x_vals, mean = mu, sd = sigma_requerido)

df <- data.frame(
  temperatura = rep(x_vals, 2),
  densidad = c(dens_actual, dens_mejorado),
  modelo = rep(c("Actual (σ = 5)", "Mejorado (σ ≈ 3.04)"), each = length(x_vals))
)

ggplot(df, aes(x = temperatura, y = densidad, color = modelo)) +
  geom_line(linewidth = 1.2) +
  geom_vline(xintercept = c(lim_inf, lim_sup), color = "red", linetype = "dashed", linewidth = 1) +
  labs(title = "Comparación de Distribuciones Térmicas",
       subtitle = "Límites de especificación: 340°C – 360°C",
       x = "Temperatura (°C)", y = "Densidad") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))

```

:::

------------------------------------------------------------------------

::: {#exr-ventas}
### Análisis de Ventas Mensuales

Las ventas mensuales de una tienda siguen $N(50000, 12000^2)$ pesos.

**Tareas**:

1.  Simula las ventas de 24 meses
2.  ¿Cuál es la probabilidad de tener ventas superiores a 60,000 pesos?
3.  ¿En cuántos meses se espera tener ventas por debajo de 30,000 pesos?
4.  Calcula el rango intercuartílico de las ventas
5.  Si la meta es superar 45,000 pesos, ¿qué porcentaje de meses se cumple?


```{r}
# Parámetros del sistema de ventas
mu_ventas <- 50000
sigma_ventas <- 12000

# Simulación de 24 meses
set.seed(2025)
ventas_mensuales <- rnorm(24, mean = mu_ventas, sd = sigma_ventas)

# Estadísticos básicos
media_ventas <- mean(ventas_mensuales)
mediana_ventas <- median(ventas_mensuales)
sd_ventas <- sd(ventas_mensuales)

cat("La media de las ventas mensuales es:", round(media_ventas, 2), "pesos\n")
cat("La mediana de las ventas mensuales es:", round(mediana_ventas, 2), "pesos\n")
cat("La desviación estándar observada es:", round(sd_ventas, 2), "pesos\n\n")

```

```{r}
# Probabilidad teórica
prob_60000_teo <- (1 - pnorm(60000, mean = mu_ventas, sd = sigma_ventas)) * 100

# Porcentaje observado
prob_60000_obs <- mean(ventas_mensuales > 60000) * 100

cat("Probabilidad de ventas > $60,000:\n")
cat(sprintf("• Observada: %.2f%%\n", prob_60000_obs))
cat(sprintf("• Teórica:   %.2f%%\n\n", prob_60000_teo))

```

```{r}
# Conteo observado
meses_bajos <- sum(ventas_mensuales < 30000)

# Probabilidad teórica
prob_30000_teo <- pnorm(30000, mean = mu_ventas, sd = sigma_ventas)
meses_bajos_teo <- round(prob_30000_teo * 24)

cat("Meses con ventas < $30,000:\n")
cat(sprintf("• Observado: %d meses\n", meses_bajos))
cat(sprintf("• Esperado (teórico): %d meses\n\n", meses_bajos_teo))

```

```{r}
# Cálculo del IQR
iqr_ventas <- IQR(ventas_mensuales)
cat("Rango intercuartílico de las ventas:", round(iqr_ventas, 2), "pesos\n\n")

```

```{r}
# Porcentaje observado
cumple_meta_obs <- mean(ventas_mensuales > 45000) * 100

# Porcentaje teórico
cumple_meta_teo <- (1 - pnorm(45000, mean = mu_ventas, sd = sigma_ventas)) * 100

cat("Cumplimiento de meta (> $45,000):\n")
cat(sprintf("• Observado: %.2f%% de los meses\n", cumple_meta_obs))
cat(sprintf("• Teórico:   %.2f%% de los meses\n", cumple_meta_teo))

```
```{r}
analisis_ventas <- function(mu, sigma, n_meses = 24, meta = 45000, limite_alto = 60000, limite_bajo = 30000) {
  set.seed(2025)
  ventas <- rnorm(n_meses, mean = mu, sd = sigma)
  
  # Estadísticos básicos
  media <- mean(ventas)
  mediana <- median(ventas)
  sd_obs <- sd(ventas)
  iqr <- IQR(ventas)
  
  # Probabilidades y conteos
  prob_alto_teo <- (1 - pnorm(limite_alto, mean = mu, sd = sigma)) * 100
  prob_alto_obs <- mean(ventas > limite_alto) * 100
  
  prob_bajo_teo <- pnorm(limite_bajo, mean = mu, sd = sigma)
  meses_bajos_teo <- round(prob_bajo_teo * n_meses)
  meses_bajos_obs <- sum(ventas < limite_bajo)
  
  prob_meta_teo <- (1 - pnorm(meta, mean = mu, sd = sigma)) * 100
  prob_meta_obs <- mean(ventas > meta) * 100
  
  # Impresión estilo chonk
  cat("DISTRIBUCIÓN DE VENTAS:\n")
  cat(sprintf("Ventas ~ N(%.0f, %.0f²) pesos\n", mu, sigma))
  cat("Meses analizados:", n_meses, "\n\n")
  
  cat("ESTADÍSTICOS DE LA MUESTRA:\n")
  cat(sprintf("• Media:   %.2f pesos\n", media))
  cat(sprintf("• Mediana: %.2f pesos\n", mediana))
  cat(sprintf("• Desviación estándar observada: %.2f pesos\n", sd_obs))
  cat(sprintf("• Rango intercuartílico: %.2f pesos\n\n", iqr))
  
  cat("VENTAS > $", limite_alto, ":\n", sep = "")
  cat(sprintf("• Observado: %.2f%%\n", prob_alto_obs))
  cat(sprintf("• Teórico:   %.2f%%\n\n", prob_alto_teo))
  
  cat("VENTAS < $", limite_bajo, ":\n", sep = "")
  cat(sprintf("• Observado: %d meses\n", meses_bajos_obs))
  cat(sprintf("• Esperado (teórico): %d meses\n\n", meses_bajos_teo))
  
  cat("CUMPLIMIENTO DE META (> $", meta, "):\n", sep = "")
  cat(sprintf("• Observado: %.2f%% de los meses\n", prob_meta_obs))
  cat(sprintf("• Teórico:   %.2f%% de los meses\n", prob_meta_teo))
}
analisis_ventas(mu = 50000, sigma = 12000)

```

```{r}
grafica_ventas <- function(mu, sigma, n_meses = 24, meta = 45000, limite_alto = 60000, limite_bajo = 30000) {
  set.seed(2025)
  ventas <- rnorm(n_meses, mean = mu, sd = sigma)
  
  library(ggplot2)
  
  ggplot(data.frame(ventas = ventas), aes(x = ventas)) +
    geom_histogram(aes(y = after_stat(density)), bins = 30, 
                   fill = "lightpink", color = "black", alpha = 0.7) +
    stat_function(fun = dnorm, args = list(mean = mu, sd = sigma),
                  color = "darkorange", linewidth = 1.5) +
    geom_vline(xintercept = c(limite_bajo, meta, limite_alto), 
               color = c("red", "blue", "darkgreen"), 
               linetype = "dashed", linewidth = 1.2) +
    annotate("text", x = limite_bajo, y = 0.00003, label = paste0("Límite bajo\n$", limite_bajo), 
             color = "red", size = 3, angle = 90, vjust = -0.5) +
    annotate("text", x = meta, y = 0.00003, label = paste0("Meta\n$", meta), 
             color = "blue", size = 3, angle = 90, vjust = -0.5) +
    annotate("text", x = limite_alto, y = 0.00003, label = paste0("Límite alto\n$", limite_alto), 
             color = "darkgreen", size = 3, angle = 90, vjust = -0.5) +
    labs(title = "Distribución de Ventas Mensuales",
         subtitle = "Líneas verticales indican meta y límites de análisis",
         x = "Ventas (pesos)", y = "Densidad") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))
}
grafica_ventas(mu = 50000, sigma = 12000)

```


:::

::: {#exr-baterias}
### Tiempo de Vida de Baterías

La duración de baterías sigue $N(1200, 150^2)$ horas.

1.  Simula la vida útil de 800 baterías
2.  ¿Qué garantía (en horas) cubre al 95% de las baterías?
3.  Si se venden 10,000 baterías con garantía de 900 horas, ¿cuántas se espera que fallen?
4.  Compara la media y mediana de tu simulación con los valores teóricos
5.  ¿Cuál es el percentil 10 de la distribución?


```{r}
# Parámetros de la distribución
mu_bateria <- 1200
sigma_bateria <- 150
n_baterias <- 800
set.seed(2025)
# Simulación de duración de baterías
vida_baterias <- rnorm(n_baterias, mean = mu_bateria, sd = sigma_bateria)
# Garantía que cubre al 95% de las baterías
garantia_95 <- qnorm(0.05, mean = mu_bateria, sd = sigma_bateria, lower.tail = FALSE)
cat("GARANTÍA RECOMENDADA:\n")
cat(sprintf("• Para cubrir el 95%% de las baterías, se recomienda una garantía de al menos %.2f horas\n\n", garantia_95))
# Probabilidad de falla con garantía de 900 horas
prob_falla <- pnorm(900, mean = mu_bateria, sd = sigma_bateria)
fallas_esperadas <- round(prob_falla * 10000)

cat("FALLAS ESPERADAS:\n")
cat(sprintf("• Con garantía de 900 horas, se espera que %.2f%% de las baterías fallen\n", prob_falla * 100))
cat(sprintf("• En un lote de 10,000 baterías, se esperan %d fallas\n\n", fallas_esperadas))

# Estadísticos observados
media_obs <- mean(vida_baterias)
mediana_obs <- median(vida_baterias)

cat("COMPARACIÓN DE ESTADÍSTICOS:\n")
cat(sprintf("• Media observada:   %.2f horas\n", media_obs))
cat(sprintf("• Mediana observada: %.2f horas\n", mediana_obs))
cat(sprintf("• Media teórica:     %.2f horas\n", mu_bateria))
cat(sprintf("• Mediana teórica:   %.2f horas\n\n", mu_bateria))  

```

```{r}
# Percentil 10 teórico
p10_teorico <- qnorm(0.10, mean = mu_bateria, sd = sigma_bateria)

cat("PERCENTIL 10:\n")
cat(sprintf("• El 10%% de las baterías duran menos de %.2f horas\n", p10_teorico))


```

```{r}
analisis_baterias <- function(mu, sigma, n_baterias = 800, garantia = 900, lote = 10000) {
  set.seed(2025)
  vida <- rnorm(n_baterias, mean = mu, sd = sigma)
  
  # Estadísticos observados
  media_obs <- mean(vida)
  mediana_obs <- median(vida)
  
  # Garantía que cubre al 95%
  garantia_95 <- qnorm(0.05, mean = mu, sd = sigma, lower.tail = FALSE)
  
  # Fallas esperadas con garantía dada
  prob_falla <- pnorm(garantia, mean = mu, sd = sigma)
  fallas_esperadas <- round(prob_falla * lote)
  
  # Percentil 10 teórico
  p10 <- qnorm(0.10, mean = mu, sd = sigma)
  
  # Impresión estilo chonk
  cat("DISTRIBUCIÓN DE VIDA ÚTIL:\n")
  cat(sprintf("Baterías ~ N(%.0f, %.0f²) horas\n", mu, sigma))
  cat("Baterías simuladas:", n_baterias, "\n\n")
  
  cat("ESTADÍSTICOS DE LA MUESTRA:\n")
  cat(sprintf("• Media observada:   %.2f horas\n", media_obs))
  cat(sprintf("• Mediana observada: %.2f horas\n", mediana_obs))
  cat(sprintf("• Media teórica:     %.2f horas\n", mu))
  cat(sprintf("• Mediana teórica:   %.2f horas\n\n", mu))  # simétrica
  
  cat("GARANTÍA RECOMENDADA:\n")
  cat(sprintf("• Para cubrir el 95%% de las baterías, se recomienda ≥ %.2f horas\n\n", garantia_95))
  
  cat("FALLAS ESPERADAS CON GARANTÍA DE", garantia, "HORAS:\n")
  cat(sprintf("• Probabilidad de falla: %.2f%%\n", prob_falla * 100))
  cat(sprintf("• En un lote de %d baterías, se esperan %d fallas\n\n", lote, fallas_esperadas))
  
  cat("PERCENTIL 10:\n")
  cat(sprintf("• El 10%% de las baterías duran menos de %.2f horas\n", p10))
}
analisis_baterias <- function(mu, sigma, n_baterias = 800, garantia = 900, lote = 10000) {
  set.seed(2025)
  vida <- rnorm(n_baterias, mean = mu, sd = sigma)
  
  # Estadísticos observados
  media_obs <- mean(vida)
  mediana_obs <- median(vida)
  
  # Garantía que cubre al 95%
  garantia_95 <- qnorm(0.05, mean = mu, sd = sigma, lower.tail = FALSE)
  
  # Fallas esperadas con garantía dada
  prob_falla <- pnorm(garantia, mean = mu, sd = sigma)
  fallas_esperadas <- round(prob_falla * lote)
  
  # Percentil 10 teórico
  p10 <- qnorm(0.10, mean = mu, sd = sigma)
  
  # Impresión estilo chonk
  cat("DISTRIBUCIÓN DE VIDA ÚTIL:\n")
  cat(sprintf("Baterías ~ N(%.0f, %.0f²) horas\n", mu, sigma))
  cat("Baterías simuladas:", n_baterias, "\n\n")
  
  cat("ESTADÍSTICOS DE LA MUESTRA:\n")
  cat(sprintf("• Media observada:   %.2f horas\n", media_obs))
  cat(sprintf("• Mediana observada: %.2f horas\n", mediana_obs))
  cat(sprintf("• Media teórica:     %.2f horas\n", mu))
  cat(sprintf("• Mediana teórica:   %.2f horas\n\n", mu))  # simétrica
  
  cat("GARANTÍA RECOMENDADA:\n")
  cat(sprintf("• Para cubrir el 95%% de las baterías, se recomienda ≥ %.2f horas\n\n", garantia_95))
  
  cat("FALLAS ESPERADAS CON GARANTÍA DE", garantia, "HORAS:\n")
  cat(sprintf("• Probabilidad de falla: %.2f%%\n", prob_falla * 100))
  cat(sprintf("• En un lote de %d baterías, se esperan %d fallas\n\n", lote, fallas_esperadas))
  
  cat("PERCENTIL 10:\n")
  cat(sprintf("• El 10%% de las baterías duran menos de %.2f horas\n", p10))
}
analisis_baterias(mu = 1200, sigma = 150)

```

```{r}
grafica_baterias <- function(mu, sigma, n_baterias = 800, garantia = 900) {
  set.seed(2025)
  vida <- rnorm(n_baterias, mean = mu, sd = sigma)
  
  # Percentil 10 teórico
  p10 <- qnorm(0.10, mean = mu, sd = sigma)
  
  library(ggplot2)
  
  ggplot(data.frame(vida = vida), aes(x = vida)) +
    geom_histogram(aes(y = after_stat(density)), bins = 40, 
                   fill = "lightpink", color = "black", alpha = 0.7) +
    stat_function(fun = dnorm, args = list(mean = mu, sd = sigma),
                  color = "darkblue", linewidth = 1.5) +
    geom_vline(xintercept = c(garantia, p10), 
               color = c("red", "darkgreen"), 
               linetype = "dashed", linewidth = 1.2) +
    annotate("text", x = garantia, y = 0.002, label = paste0("Garantía\n", garantia, " h"), 
             color = "black", size = 3, angle = 90, vjust = -0.5) +
    annotate("text", x = p10, y = 0.002, label = paste0("Percentil 10\n", round(p10, 1), " h"), 
             color = "black", size = 3, angle = 90, vjust = -0.5) +
    labs(title = "Distribución de Vida Útil de Baterías",
         subtitle = "Líneas verticales indican garantía y percentil 10",
         x = "Horas de duración", y = "Densidad") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))
}
grafica_baterias(mu = 1200, sigma = 150)

```


:::

------------------------------------------------------------------------

::: {#exr-errores_medicion}
### Análisis de Errores de Medición

Los errores de un instrumento de medición siguen $N(0, 2.5^5)$ unidades.

1.  Simula 1000 mediciones
2.  ¿Qué porcentaje de errores está entre -5 y +5 unidades?
3.  Calcula la probabilidad de que un error sea mayor a 6 unidades en valor absoluto
4.  Si se considera "preciso" un error ≤ 3 unidades, ¿qué porcentaje de mediciones son precisas?
5.  Verifica que la distribución es simétrica alrededor de 0


```{r}
# Parámetros de la distribución de errores
mu_error <- 0
sigma_error <- 2.5
n_mediciones <- 1000
set.seed(2025)

# Simulación de errores de medición
errores <- rnorm(n_mediciones, mean = mu_error, sd = sigma_error)

# Porcentaje observado
porcentaje_entre_5_obs <- mean(errores >= -5 & errores <= 5) * 100

# Porcentaje teórico
porcentaje_entre_5_teo <- (pnorm(5, mean = mu_error, sd = sigma_error) - 
                           pnorm(-5, mean = mu_error, sd = sigma_error)) * 100

cat("ERRORES ENTRE -5 Y +5 UNIDADES:\n")
cat(sprintf("• Observado: %.2f%%\n", porcentaje_entre_5_obs))
cat(sprintf("• Teórico:   %.2f%%\n\n", porcentaje_entre_5_teo))

```
## Probabilidad de error > 6 unidades en valor absoluto

```{r}
# Probabilidad teórica
prob_abs_gt6_teo <- (1 - pnorm(6, mean = mu_error, sd = sigma_error)) +
                    pnorm(-6, mean = mu_error, sd = sigma_error)
prob_abs_gt6_teo <- prob_abs_gt6_teo * 100

# Porcentaje observado
porcentaje_abs_gt6_obs <- mean(abs(errores) > 6) * 100

cat("ERRORES MAYORES A 6 UNIDADES (|error| > 6):\n")
cat(sprintf("• Observado: %.2f%%\n", porcentaje_abs_gt6_obs))
cat(sprintf("• Teórico:   %.2f%%\n\n", prob_abs_gt6_teo))

```
## Porcentaje de mediciones "precisas" (|error| ≤ 3)

```{r}
# Porcentaje observado
porcentaje_preciso_obs <- mean(abs(errores) <= 3) * 100

# Porcentaje teórico
porcentaje_preciso_teo <- (pnorm(3, mean = mu_error, sd = sigma_error) - 
                           pnorm(-3, mean = mu_error, sd = sigma_error)) * 100

cat("MEDICIONES PRECISAS (|error| ≤ 3):\n")
cat(sprintf("• Observado: %.2f%%\n", porcentaje_preciso_obs))
cat(sprintf("• Teórico:   %.2f%%\n\n", porcentaje_preciso_teo))

```

## Verificación de simetría

```{r}
# Simetría observada
simetria <- abs(mean(errores) - mu_error) < 0.1

cat("VERIFICACIÓN DE SIMETRÍA:\n")
cat(sprintf("• Media observada: %.4f\n", mean(errores)))
cat(sprintf("• La distribución es %s alrededor de 0\n", ifelse(simetria, "simétrica", "ligeramente asimétrica")))

```

```{r}
analisis_errores <- function(mu = 0, sigma = 2.5, n = 1000, rango = 5, extremo = 6, umbral_preciso = 3) {
  set.seed(2025)
  errores <- rnorm(n, mean = mu, sd = sigma)
  
  # Estadísticos básicos
  media_obs <- mean(errores)
  mediana_obs <- median(errores)
  
  # Porcentaje entre ±rango
  pct_rango_obs <- mean(errores >= -rango & errores <= rango) * 100
  pct_rango_teo <- (pnorm(rango, mean = mu, sd = sigma) - pnorm(-rango, mean = mu, sd = sigma)) * 100
  
  # Porcentaje de errores extremos (|error| > extremo)
  pct_extremo_obs <- mean(abs(errores) > extremo) * 100
  pct_extremo_teo <- (1 - pnorm(extremo, mean = mu, sd = sigma) + pnorm(-extremo, mean = mu, sd = sigma)) * 100
  
  # Porcentaje de errores precisos (|error| ≤ umbral_preciso)
  pct_preciso_obs <- mean(abs(errores) <= umbral_preciso) * 100
  pct_preciso_teo <- (pnorm(umbral_preciso, mean = mu, sd = sigma) - pnorm(-umbral_preciso, mean = mu, sd = sigma)) * 100
  
  # Verificación de simetría
  simetria <- abs(media_obs - mu) < 0.1
  
  # Impresión estilo chonk
  cat("DISTRIBUCIÓN DE ERRORES:\n")
  cat(sprintf("Errores ~ N(%.1f, %.1f²) unidades\n", mu, sigma))
  cat("Mediciones simuladas:", n, "\n\n")
  
  cat("ESTADÍSTICOS DE LA MUESTRA:\n")
  cat(sprintf("• Media observada:   %.4f\n", media_obs))
  cat(sprintf("• Mediana observada: %.4f\n", mediana_obs))
  cat(sprintf("• Media teórica:     %.4f\n\n", mu))
  
  cat(sprintf("ERRORES ENTRE ±%.0f UNIDADES:\n", rango))
  cat(sprintf("• Observado: %.2f%%\n", pct_rango_obs))
  cat(sprintf("• Teórico:   %.2f%%\n\n", pct_rango_teo))
  
  cat(sprintf("ERRORES EXTREMOS (|error| > %.0f):\n", extremo))
  cat(sprintf("• Observado: %.2f%%\n", pct_extremo_obs))
  cat(sprintf("• Teórico:   %.2f%%\n\n", pct_extremo_teo))
  
  cat(sprintf("MEDICIONES PRECISAS (|error| ≤ %.0f):\n", umbral_preciso))
  cat(sprintf("• Observado: %.2f%%\n", pct_preciso_obs))
  cat(sprintf("• Teórico:   %.2f%%\n\n", pct_preciso_teo))
  
  cat("VERIFICACIÓN DE SIMETRÍA:\n")
  cat(sprintf("• La distribución es %s alrededor de %.1f\n", ifelse(simetria, "simétrica", "ligeramente asimétrica"), mu))
}
analisis_errores()

```

```{r}
grafica_errores <- function(mu = 0, sigma = 2.5, n = 1000, rango = 5, extremo = 6, umbral_preciso = 3) {
  set.seed(2025)
  errores <- rnorm(n, mean = mu, sd = sigma)
  
  library(ggplot2)
  
  ggplot(data.frame(error = errores), aes(x = error)) +
    geom_histogram(aes(y = after_stat(density)), bins = 40, 
                   fill = "lightcoral", color = "black", alpha = 0.7) +
    stat_function(fun = dnorm, args = list(mean = mu, sd = sigma),
                  color = "darkred", linewidth = 1.5) +
    geom_vline(xintercept = c(-rango, rango), color = "blue", linetype = "dashed", linewidth = 1.2) +
    geom_vline(xintercept = c(-umbral_preciso, umbral_preciso), color = "green", linetype = "dashed", linewidth = 1.2) +
    geom_vline(xintercept = c(-extremo, extremo), color = "purple", linetype = "dashed", linewidth = 1.2) +
    annotate("text", x = rango, y = 0.05, label = paste0("±", rango, " unidades"), 
             color = "blue", size = 3, angle = 90, vjust = -0.5) +
    annotate("text", x = umbral_preciso, y = 0.05, label = paste0("Precisión ±", umbral_preciso), 
             color = "green", size = 3, angle = 90, vjust = -0.5) +
    annotate("text", x = extremo, y = 0.05, label = paste0("Extremo ±", extremo), 
             color = "purple", size = 3, angle = 90, vjust = -0.5) +
    labs(title = "Distribución de Errores de Medición",
         subtitle = "Zonas de precisión, rango aceptable y errores extremos",
         x = "Error (unidades)", y = "Densidad") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))
}
grafica_errores()

```

:::

::: {#exr-examen_corporativo}
### Puntuaciones de Examen Comparativo

Dos grupos toman el mismo examen. Grupo A: $N(75, 10^2)$, Grupo B: $N(82, 8^2)$.

1.  Simula 200 estudiantes de cada grupo
2.  ¿Qué porcentaje de estudiantes del Grupo A supera la media del Grupo B?
3.  ¿Cuál es la probabilidad de que un estudiante del Grupo B tenga puntuación menor a 70?
4.  Compara las distribuciones visualmente
5.  ¿A partir de qué puntuación está el 10% superior de cada grupo?

## 1. Simulación de 200 estudiantes por grupo
```{r}
set.seed(2025)

# Parámetros
mu_A <- 75; sigma_A <- 10
mu_B <- 82; sigma_B <- 8

# Simulación
grupo_A <- rnorm(200, mean = mu_A, sd = sigma_A)
grupo_B <- rnorm(200, mean = mu_B, sd = sigma_B)

```


## ¿Qué porcentaje del Grupo A supera la media del Grupo B?
```{r}
# Porcentaje observado
porcentaje_A_supera_B <- mean(grupo_A > mu_B) * 100

# Probabilidad teórica
prob_A_supera_B <- (1 - pnorm(mu_B, mean = mu_A, sd = sigma_A)) * 100

cat("GRUPO A SUPERA LA MEDIA DE GRUPO B:\n")
cat(sprintf("• Observado: %.2f%%\n", porcentaje_A_supera_B))
cat(sprintf("• Teórico:   %.2f%%\n\n", prob_A_supera_B))

```

## ¿Probabilidad de que Grupo B tenga puntuación < 70?

```{r}
# Probabilidad teórica
prob_B_menor_70 <- pnorm(70, mean = mu_B, sd = sigma_B) * 100

# Porcentaje observado
porcentaje_B_menor_70 <- mean(grupo_B < 70) * 100

cat("PUNTUACIONES < 70 EN GRUPO B:\n")
cat(sprintf("• Observado: %.2f%%\n", porcentaje_B_menor_70))
cat(sprintf("• Teórico:   %.2f%%\n\n", prob_B_menor_70))

```

## Comparación visual de distribuciones

```{r}
library(ggplot2)

df <- data.frame(
  puntuacion = c(grupo_A, grupo_B),
  grupo = rep(c("Grupo A", "Grupo B"), each = 200)
)

ggplot(df, aes(x = puntuacion, fill = grupo)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, alpha = 0.6, position = "identity", color = "black") +
  stat_function(fun = dnorm, args = list(mean = mu_A, sd = sigma_A), color = "darkblue", linewidth = 1.2) +
  stat_function(fun = dnorm, args = list(mean = mu_B, sd = sigma_B), color = "darkgreen", linewidth = 1.2) +
  labs(title = "Distribución de Puntuaciones por Grupo",
       subtitle = "Grupo A: N(75, 10²) | Grupo B: N(82, 8²)",
       x = "Puntuación", y = "Densidad") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))

```

## ¿A partir de qué puntuación está el 10% superior?

```{r}
# Percentil 90 (inicio del 10% superior)
p90_A <- qnorm(0.90, mean = mu_A, sd = sigma_A)
p90_B <- qnorm(0.90, mean = mu_B, sd = sigma_B)

cat("PUNTUACIÓN DEL 10% SUPERIOR:\n")
cat(sprintf("• Grupo A: %.2f puntos\n", p90_A))
cat(sprintf("• Grupo B: %.2f puntos\n", p90_B))

```


:::
:::::::::
